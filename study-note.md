# 学习手记

- 变量默认是不可变（immutable）的。添加 mut 关键字可将变量定义为可变的（mutable）。
- Rust 不提供基础类型之间的隐式类型转换，只能使用 `as` 关键字显式转换类型。
- 使用 type 关键字定义某个类型的别名。类型名称必须采用骆驼命名法（即所有单词首字母大写），否则编译器将警告。只有基础类型（uint f32等）例外。
- Rust里面几乎所有语句（statement）都是表达式（expression），也就是具有值。在表达式结尾加上分号`;`可忽略掉该值。
- 代码块（Blocks）也是表达式，因而也能作为赋值语句中的右值（r-values）。 代码块的最后一条表达式的值，将作为该代码块的值，被赋值给左值（l-value）。 但是，如果代码块的最后一条语句以分号`;`结尾，其值将是`()`，也就是没有值。
- Rust的if-else分支判断语句类似于C语言。但跟C不同的是，逻辑型条件不需要用小括号括起来，条件后面必须跟一个代码块。 if-else语句也是表达式，每个分支必须返回相同的类型，以保证类型安全。
- 默认情况, 模块里的条目的可见性是私有的, 但是可以使用 `pub` 将其设置成公开有. 在模块内, 只有 `public` 条目允许在模块外部访问.
- 使用 `use` 以全路径形式导入模块或方法,可以同时 `as` 取别名,以简化调用方式.
- 访问的项目时，可以在路径中使用`super`和`self`键字来消除歧义。
- 库(Crates)
- 接口(Traits)
- safe shared mutable state. 安全共享的可变状态。
- 表达式返回一个值，而语句不是。
- 元组索引使用 .
- /// 文档注释
- `//!`，用来注释包含它的项（也就是说，crate，模块或者函数），而不是位于它之后的项。
- 模块层文档以 `//!` 开头，函数层文档以 `///` 开头。在注释中Rust文档支持Markdown，三个‘`’标记代码块。按惯例包含# Example
- 有一个相关的环境的匿名函数叫做“闭包”，因为它们包含在同一个环境中。
- `{}`是一个表达式
- 用`=>`来定义关联类型。
- FFI Foreign Function Interface
- Rust强制确保“锁住的是数据，而非代码”。
- unreachable!()宏
- `Debug trait`让我们可以使用`{:?}`格式运算符打印枚举值。
- 值得注意的是你只能在一个返回Result的函数中使用`try!`，这意味着你不能在`main()`中使用`try!`，因为`main()`不返回任何东西。
- Rc: refcount, 引用计数
- Arc: 原子计数
- 在Rust中赋值的值是一个空的元组`()`
- match也是一个表达式，也就是说它可以用在let绑定的右侧或者其它直接用到表达式的地方
- Rust并没有方法重载，命名参数或者可变参数。利用创建者模式来代替。
- Rust有两种主要的字符串类型：`&str`和`String`。
    - `&str`叫做字符串片段（string slices）。字符串常量是`&'static str`类型的: `let greeting = "Hello there."; // greeting: &'static str`
    - 一个`String`，是一个在堆上分配的字符串。通常通过一个字符串片段调用`to_string`方法转换而来。
    - `String`可以通过一个`&`强制转换为`&str`
    - `&str`可以不用转换不过`String`必须使用`&*`显式转换。
    - 把String转换为&str的代价很小，不过从&str转换到String涉及到分配内存。
- 泛型在类型理论中叫做参数多态（parametric polymorphism），它意味着它们是对于给定参数（parametric）能够有多种形式（`poly`是多，`morph`是形态）的函数或类型。
- 当涉及到多态的代码时，需要一个机制来决定哪个具体的版本应该得到执行。这叫做“分发”（dispatch）。大体上有两种形式的分发：静态分发和动态分发。虽然Rust喜欢静态分发，不过它也提供了一个叫做“trait对象”的机制来支持动态分发。
- 有一个相关的环境的匿名函数叫做“闭包”，因为它们包含在同一个环境中。
- 可以使用`move`关键字强制使我们的闭包取得它环境的所有权

